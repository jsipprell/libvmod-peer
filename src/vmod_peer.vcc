$Module peer 3 Varnish 4.0.0+  Cache Peering Module

|
| // Send all backend requests to a statistics tracking peer
| sub vcl_init {
|    // Create new peer to be contacted at 10.1.2.3 port 8000, can only be called in vcl_init
|    new cache_peer = peer.ip("10.1.2.3",8000);
|    // 250ms connect timeout
|    cache_peer.set_connect_timeout(250);
|    // 2 second total timeout per-connection
|    cache_peer.set_timeout(2000);
|    // Up to five threads (per this object)
|    cache_peer.set_threads(1,5);
| }
|
| sub vcl_backend_fetch {
|    cache_peer.enqueue();
| }

DESCRIPTION
===========

Varnish module that utilizes libcurl calls to assist in multiplexing HTTP
operations to other Varnish neighbors or even remote Content Distribution
Networks. Such HTTP calls are performed asyncronously via a separate thread
pool.

$Object ip(IP,INT)

Returns a new peering object which will be able to communicate asyncronously
with the specificed IP address and destination port number

Caveats
        Specifying a port number of 0 will always use the standard HTTP port
        (80). The cache peer object can only be created from within
        `vcl_init`.

        This function does* **not** *set the HTTP "Host" header.* The ``Host``
        header is set to whatever the current ``req.http`` headers contain at
        the time `cache_peer.enqueue()` or `cache_peer.enqueue_post()` is
        called. If you need to set ``Host`` change ``req.http`` (or
        ``bereq.http``) immediately before queueing a request and then change
        it back immediately after.
Example
        new cache_peer = peer.ip("10.1.2.3",0);

$Method VOID .set_threads(INT, INT)

Description
        Configures the minimum and maximum number of worker threads which will
        be started in order to perform queued HTTP operations in the
        background. By default both minimum and maximum are set to 1, which is
        also the minimum number configureable. Setting min or max to 0 results
        in no change to the actual min/max setting but can be used to change
        one without the other. Attempts to set conflicting or non-sense values
        will be silently ignored.

        When the maximum number of threads is greater than the minimum, the
        number of running threads will be scaled based on workload.

        Setting min to a value greater than the current number of running
        worker threads will result in new threads spawning immediately while
        conversely setting max *below* the current number will result in excess
        threads terminating immediately.

Example
        ::

            // Set the new maximum threads to 4 without changing the mininum
            cache_peer.set_threads(0,4);

$Method INT .min_threads()

Description
        Returns the minimum number of threads maintained by the HTTP request
        handling pool. This number should be the same as the first argument in
        the most recent call to ``cache_peer.set_threads(min,max);``.

        The default value is 1.

$Method INT .max_threads()

Description
        Returns the maximum number of threads maintained by the HTTP
        request handling pool. This number should be the same as the first
        argument in the most recent call to ``cache_peer.set_threads(min,max);``

        The default value is 1.

        If the maximum has been set to a value greater than the minimum,
        the number of actively running threads will be adjusted dynamically
        based on the pending queue size.


$Method INT .threads()

Description
        Returns the number of threads currently running in the thread pool
        dedicated to handling `vmod_peer` HTTP requests. No distinction is
        made between busy threads and those waiting for new requests but
        this can generally be estimated by examining this value and the
        ``cache_peer.pending()`` value.

$Method VOID .set_timeout(INT)

Description
        Set the global (per-operation) HTTP timeout (*starting after connect*)
        in milliseconds. Operations which exceed this time will fail in the
        background and add an **Error** entry in the Varnish shared memory log.
Example
        ::

            // Set post-connect timeout to .5 seconds
            cache_peer.set_timeout(500);

$Method VOID .set_connect_timeout(INT)

Description
        Set the global (per-operation) HTTP connection timeout in milliseconds.
        Operations which exceed this time before HTTP has started will fail in
        the background and add an **Error** entry in the Varnish shared memory
        log.
Example
        ::

            Set connect timeout to .1 seconds
            cache_peer.set_connect_timeout(100);

$Method VOID .enqueue()
Description
        Queue a new asyncronous HTTP request for processing by a background
        thread.  The request will be based on the state of the Varnish ``req``
        or ``bereq`` object at the time this function is called. Which object
        is used is based on the VCL function `enqueue` is called from.  If
        called from `vcl_backend_fetch`, `vcl_backend_response` or
        `vcl_backend_error` then ``bereq`` will be used. If called from any
        other VCL function the ``req`` object will be used.

        All headers in ``req.http`` will be copied to this request except for
        the `Connection` header.  *vmod_peer* does not use http keepalives and
        thus `Connection: close` is **always** used. In addition to headers,
        ``req.url``/``bereq.url``, ``req.request``/``bereq.request`` and
        ``req.proto``/``bereq.proto`` are also used when preparing the new
        request. Once this function has been called, ``req`` or ``bereq`` can
        be altered, delivered or discarded at will without changing the
        background request in progress.
Caveats
        The ``req.http.host`` or ``bereq.http.host`` header will be used to
        establish the background HTTP connection. If no host header is set a
        header will be generated based on the IP the cache peering object was
        created with (see ``peer.ip()`` in `vcl_init`).
Example
        ::

            // Turn GET requests into PURGEs for a neighboring cache
            if (req.request == "GET") {
                set req.request = "PURGE";
                cache_peer.enqueue();
                set req.request = "GET";
            }

$Method VOID .enqueue_post(STRING_LIST)

Description
        Identical to `cache_peer.enqueue()` except that it takes a single
        argument which will be used as HTTP ``POST`` content.  The content
        will be automatically URL-encoding before being sent. Note that using
        this function will cause the HTTP operation to *always* operate as a
        ``POST`` irrespective of value of `req.request` or `bereq.request`
        (although `req.request`/`breq.request` will be the method actually
        sent in the HTTP command).
Example
        ::

            // Send an HTTP POST from vcl_backend_response
            set bereq.request = "POST';
            cache_peer.enqueue_post({"Form entry
            sent "} + now);

$Method VOID .enqueue_cached_post()

Description
        Identical to `cache_peer.enqueue_post("...")` except that it takes no
        arguments but instead uses the `HTTP POST` data cached via a prior
        call to `peer.cache_post()`.
Caveats
        `peer.cache_post()` not only must be called prior to
        `cache_peer.enqueue_cached_post()`, but `peer.cache_post()` can
        **only** be called in ``vcl_recv``. Note that it is perfectly
        acceptable to call this method in a later VCL handler, *including from
        a backend handler* (i.e. ``vcl_backend_fetch`` or
        ``vcl_backend_response``). Only `peer.cache_post()` must be called
        from ``vcl_recv``.
Example
        ::

            // Send an HTTP POST to a lookaside cache subsystem
            sub vcl_init {
                new mypeer = peer.ip("10.1.2.3",8080);
            }
            // Make sure any POST request bodies get cached.
            sub vcl_recv {
                if (req.method == "POST") {
                    peer.cache_post();
                }
            }
            // After each successful catch fetch queue it to our peer.
            sub vcl_backend_response {
                if(beresp.status == 200) {
                    mypeer.enqueue_cached_post();
                }
            }

$Method INT .pending()

Description
        Returns the number of outstanding HTTP requests that have not
        yet been processed. Requests are considered pending up until
        they are initiated, **not** when completed.

$Method VOID .set_ssl(STRING, STRING)

Description
        Enables SSL support (HTTPS scheme) for queued connections. The first
        argument should be a path to the location of the Certificate Authority
        file to be used to determine certificate trusts. This argument can be
        empty ("") if a cafile is not desired. The second argument may be a
        path to a directory containing Certificate Authority certs. This
        argument may be empty ("") if a capath is not desired.
Example
        ::

            // Enable SSL and trust a private CA
            cache_peer.set_ssl("/var/lib/ssl/private_ca.pem","");

$Method VOID .set_ssl_verification(ENUM { peer, host, force }, BOOL)

Description
        Enable or disable SSL certificate verification for HTTPS requests
        using a given peer object. Verification can be enabled or disabled
        based on the SSL "peer" or the SSL "host".
Example
        ::

            // Disable SSL peer verification
            cache_peer.set_ssl_verification(peer, false);
            // Enable SSL host verification
            cache_peer.set_ssl_verification(host, true);

$Method STRING .body()

Description
        Return cached request body (usually due to an HTTP `POST`).

$Function VOID cache_post()

Description
        Cache an HTTP `POST` request body so that it can later be retrieved or
        queued to an external connection via ``cache_peer.body()`` and
        ``cache_peer.enqueue_cached_post()``.
Caveats
        This function can **only** be called in `vcl_recv`. The
        ``cache_peer.body()`` method will attempt to perform this function if
        it is used inside of `vcl_recv`.
Example
        ::

            sub vcl_init {
                new cp = peer.ip("127.0.0.1",0);
            }
            sub vcl_recv {
                if (req.method == "POST") {
                    peer.cache_post();
                }
            }
            sub vcl_miss {
                if (req.method == "POST") {
                    cp.enqueue_cached_post();
                    return (synth(404,"Post content: "+cp.body()));
                }
            }

